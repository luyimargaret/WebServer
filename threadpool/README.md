# thread.h

![图片](https://user-images.githubusercontent.com/44019236/180019269-97237635-055e-47d9-a256-157ef14b6f8b.png)

实现一个图示的半同步/半反应堆并发模式的线程池,使用一个工作队列,主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。

## 相关知识

### 1.服务器编程基本框架

![图片](https://user-images.githubusercontent.com/44019236/180019433-fa7b7003-da1d-4c80-be39-5576979cf286.png)

主要由I/O单元,逻辑单元和网络存储单元组成,每个单元之间通过请求队列进行通信,从而协同完成任务.

- I/O单元用于处理客户端的连接,读写网络数据
  - IO处理单元是服务器管理客户连接的模块。它通常要完成以下工作:等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是，数据的收发不一定在I/О处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。
- 逻辑单元用于处理逻辑业务的线程
  - 一个逻辑单元通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给IO处理单元或者直接发送给客户端（具体使用哪种方式取决于事件处理模式)。

- 网络单元指本地数据库和文件
  - 网络存储单元可以是数据库、缓存和文件，甚至是一台独立的服务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单元。

- 请求队列是各单元之间的通信方式的抽象。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分.

#### 1.1 I/O处理单元相关

##### 1.1.1I/O模型

- **阻塞IO:**调用者调用了某个函数,等待这个函数返回,期间什么也不做,不停的去检查这个函数有没有返回,必须等这个函数返回后才能进行下一步操作.socket 的基础API中，可能被阻塞的系统调用包括accept、send、recv和 connect。
- **非阻塞IO**:针对非阻塞IO执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。此时我们必须根据errno来区分这两种情况。对 accept. send和recv而言，事件未发生时errno通常被设置成EAGAIN或者EWOULDBLOCK;对connect而言，errno则被设置成EINPROGRES。
- **I/O复用**:I/O复用是最常使用的IO通知机制。它指的是，应用程序通过IO复用函数向内核注册一组事件，内核通过IO复用函数把其中就绪的事件通知给应用程序。Linux 上常用的IO复用函数是**select、poll和 epoll_wait**。需要指出的是，IO复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个IO事件的能力。

- **信号驱动I/O**:linux用套接口进行信号驱动IO,安装一个信号处理函数,进程继续运行并不阻塞,当IO时间就绪,进程收到SIGIO信号.然后处理IO事件.

- **异步I/O**:linux中可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区大小\文件偏移以及同通知的方式,然后立即返回,当内核将数据拷贝到缓冲区后,再通知应用程序.

  **注意**:阻塞IO,非阻塞IO,信号驱动IO和IO复用都是同步IO.**同步IO指内核向应用程序通知的是就绪事件,比如只通知有客户端连接,要求用户代码自行执行IO操作.异步IO指内核向应用程序通知的是完成事件,比如读取客户端的数据后才通知应用程序,由内核完成IO操作.**

##### 1.1.2两种高效的事件处理模式

- **Reactor模式:**Reactor是这样一种模式，它要求主线程（IO处理单元）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元)。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。**通常由同步IO实现**.
- **Proacter模式**:与Reactor模式不同，Proactor模式将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。因此，Proactor模式更符合上面描述的服务器编程框架。**通常由异步IO实现.**

##### 1.1.3同步IO模拟Proactor模式

原理是:主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。
使用同步IO模型（仍然以epoll_wait为例）模拟出的Proactor模式的工作流程如下:

> 1)主线程往epoll内核事件表中注册socket 上的读就绪事件。
>
> 2）主线程调用epoll_wait等待socket上有数据可读。
> 3）当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插人请求队列。
> 4）睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll 内核事件表中注册socket 上的写就绪事件。
> 5)主线程调用epoll_wait 等待socket可写。
> 6）当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。

#### 1.2IO逻辑单元相关

##### 1.2.1两种高效的并发编程模式

并发编程的目的是让程序“同时”执行多个任务。如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使效率降低。但如果程序是IO密集型的，比如经常读写文件，访问数据库等，则情况就不同了。由于IO操作的速度远没有CPU的计算速度快，所以让程序阻塞于IO操作将浪费大量的CPU时间。如果程序有多个执行线程，则当前被IO操作所阻塞的执行线程可主动放弃CPU(或由操作系统来调度)，并将执行权转移到其他线程。这样一来，CPU就可以用来做更加有意义的事情（除非所有线程都同时被IO操作所阻塞)，而不是等待I/O操作完成，因此CPU的利用率显著提升。**从实现上来说，并发编程主要有多进程和多线程两种方式.**

并发模式是指IO处理单元和多个逻辑单元之间协调完成任务的方法。**服务器主要有两种并发编程模式:半同步/半异步(half-sync/half-async）模式和领导者/追随者（Leader/Followers〉模式。**

**半同步/半异步模式中的“同步”和“异步”与前面讨论的IO模型中的“同步和“异步”是完全不同的概念。在I/O模型中,“同步”和“异步”区分的是内核向应用程序通知的是何种IO事件（是就绪事件还是完成事件)，以及该由谁来完成I/O读写（是应用程序还是内核)。在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行﹔“异步指的是程序的执行需要由系统事件来驱动。**常见的系统事件包括中断、信号等。按照同步方式运行的线程称为同步线程，按照异步方式运行的线程称为异步线程。显然，异步线程的执行效率高，实时性强，这是很多嵌入式程序采用的模型。但编写以异步方式执行的程序相对复杂，难于调试和扩展，而且不适合于大量的并发。而同步线程则相反，它虽然效率相对较低，实时性较差，但逻辑简单。因此，对于像服务器这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程序，我们就应该同时使用同步线程和异步线程来实现，即采用半同步/半异步模式来实现。**半同步/半异步模式中，同步线程用于处理客户逻辑，相当于逻辑单元﹔异步线程用于处理IO事件，相当于IO处理单元。**异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，则取决于请求队列的设计。比如最简单的轮流选取工作线程的Round Robin算法，也可以通过条件变量或信号量来随机地选择一个工作线程。在服务器程序中，如果结合考虑两种事件处理模式和几种IO模型，则半同步/半异步模式就存在多种变体。其中有一种变体称为**半同步/半反应堆(half-sync/half-reactive）模式**.

- **半同步/半异步模式工作流程**

  - > - 同步线程用于处理客户逻辑
    >
    > - 异步线程用于处理IO事件
    > - 异步线程监听到客户请求后,将其封装成请求对象并插入请求队列中
    > - 请求队列将通知某个工作在**同步模式的工作线程**来读取并处理该请求对象

##### 1.2.2半同步/半反应堆模式

- 半同步/半反应堆工作流程(以Proactor模式为例)

  - > - 异步线程充当主线程,负责监听所有socket事件
    > - 若有新请求到来,主线程接收并得到新的连接socket,然后往epoll内核事件表中注册该socket上的读写事件
    > - 如果连接socket上有读写事件发生,主线程从socket上接收数据,并将数据封装成请求对象插入到队列中
    > - 所有工作线程睡在请求队列上,当有任务到来时,通过竞争获得任务的接管权

### 2. 线程池

- 空间换时间,浪费服务器的硬件资源,换取运行效率
- 池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.
- 当服务器进入正式运行阶段,开始处理客户的请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配
- 当服务器处理完一个客户链接之后,可以把相关的资源放入池中,无需执行系统调用释放资源

### 3.静态成员变量

- 将类成员变量声明为static,则为静态成员变量.与一般成员变量不同,无论建立多少对象,都只有一个静态成员变量的拷贝,静态成员变量属于一个类,所有对象共享.
- 静态成员在编译阶段就分配了空间,也就是说对象还没创建时就已经分配了空间,位于全局静态区.
- 静态成员变量
  - 最好是类内声明,类外初始化(以免类名访问静态成员访问不到)
  - 无论公有私有,静态成员都可以在类外定义,但私有成员仍有访问权限
  - 非静态成员,类外不能初始化
  - 静态成员数据是共享的
- 静态成员函数
  - 静态成员函数可以直接访问静态成员变量,不能直接访问普通成员变量,但可以通过参数传递的方式访问
  - 普通成员函数可以访问普通成员变量,也可以访问静态成员变量
  - 静态成员函数没有this指针.非静态成员由对象单独维护,但静态成员函数为共享函数,无法区分那个对象,因此不能直接访问普通变量成员,也没有this指针.

### 4.线程池分析

线程池的设计模式为半同步/半反应堆,其中反应堆具体为Proacter事件处理模式.

**具体的,主线程为异步线程,负责监听描述符,接收socket新连接,若当前监听的socket发生了读写事件,将任务插入请求队列.工作线程从请求队列去除任务完成读写数据的处理**

